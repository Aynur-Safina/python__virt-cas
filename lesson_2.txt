name = input("Введите имя: ")
date = int(input('Введите Ваш возраст: '))
print('Привет', name, '. Ты', 2023-date, 'года рождения', sep='^-^')

_______________________________________________________
Тема:         ПЕРЕМЕННЫЕ
________________________________________________________  

                   Имя переменной
1. В имени переменной используйте только латинские буквы 
a-z, A-Z, цифры и символ нижнего подчеркивания (_);

2. Имя переменной не может начинаться с цифры;

3. Имя переменной по возможности должно отражать её назначение.

4. Запомни: Python — регистрочувствительный язык. 
Переменная name и Name — две совершенно разные переменные. 
Для именования переменных принято использовать стиль lower_case_with_underscores (слова из маленьких букв 
с подчеркиваниями).
 

               Множественное присваивание
В языке Python можно за одну инструкцию присваивания 
изменять значение сразу нескольких переменных. Делается это так:

name, surname = 'Timur', 'Guev'
print('Имя:', name, 'Фамилия:', surname)
Этот код можно записать и так:

name = 'Timur'
surname = 'Guev'
print('Имя:', name, 'Фамилия:', surname)
Отличие двух способов состоит в том, что множественное 
присваивание в первом способе присваивает значение двум 
переменным одновременно.

Если требуется считать текст с клавиатуры и присвоить его 
в качестве значения переменным, то можно написать так: 

name, surname = input(), input()
print('Имя:', name, 'Фамилия:', surname)
Если слева от знака «равно» в множественном присваивании 
должны стоять через запятую имена переменных, то справа 
могут стоять произвольные выражения, разделённые запятыми. 
Главное, чтобы слева и справа от знака присваивания было 
одинаковое число элементов.

Множественное присваивание удобно использовать, когда 
нужно обменять значения двух переменных. В Python это делается так:

name1 = 'Timur'
name2 = 'Gvido'
name1, name2 = name2, name1


____________________________________________________
Тема:      ТИПЫ ДАННЫХ (основные)
____________________________________________________

1) int - целые числа (+-ые и -ые)

2) 'str' (/"str") - строка:
                  любые символы,
                  которые помещены в одинарные
                  или двойные кавычки

3) float - дробные числа
            Пишутся через (.)
            Например 3.14

4) bool - логический тип
          2 значения: True / False
          Значения обязательно пишется с большой буквы

5) long


 Зачем нужно разделение на типы данных:
 1) с разными типами можно выполнять разные операции
 2) у разных типов разная длина, след-но,
    требуется разный обьем памяти для ее
    храненияю чтобы сэкономить, нужна
    дифференцияация типов данных

_______________________________________________________

Python — объектно-ориентированный язык программирования, его 
основу составляют объекты и классы. Объект — это область памяти 
компьютера, которая описывается типом (он же класс) и значением.
 При этом от типа зависит область значений объекта, операции 
 и методы, которые к нему можно применять.

Python предоставляет богатый набор встроенных типов данных. 
Поэтому при решении стандартных задач питонист реже пишет 
собственные классы, чем, например, разработчик на Java.


                  СТРОГАЯ ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ
_________________________________________________________                  
Python — язык программирования со строгой динамической типизацией.

«Строгая» означает, что язык не производит неявные преобразования 
типов и не создаёт сюрпризов при их случайном смешении.

Чтобы понять, о чём идёт речь, запустите этот код на Python и 
JavaScript, а затем сравните результаты:

#классический пример из JavaScript
some_number = 1 + '1'

JavaScript любезно выдаст строку '11', а Python выругается такой 
фразой:

TypeError: unsupported operand type (s) for +: 'int' and 'str'

Строгий интерпретатор забьёт тревогу и не позволит разработчику 
смешать типы.

«Динамическая» означает, что типы объектов определяются в процессе 
исполнения программы (runtime). Поэтому питонисты могут не указывать
типы переменных. Переменные в Python — это всего лишь указатели на
 объекты, они не содержат информации о типе.

Вы можете создавать и изменять переменные в любой момент, 
главное — присвойте значение:

#год рождения — целое число 1995
year_of_birth = 1995

print(year_of_birth)

#заменили на строку «nineteen ninety five»
year_of_birth = "nineteen ninety five"

print(year_of_birth)
А вот в языках со статической типизацией, таких как C++, 
C# 
и Java, типы объектов определяются ещё на этапе компиляции. 
Поэтому при попытке запустить такой код, например, в C++ компилятор выдаст ошибку:

«невозможно преобразовать „const char [20]“ в „int“»

Придётся объявлять новую переменную:

int main()
{
	int year_of_birth{ 5 };
    
	std::cout << year_of_birth << std::endl;

      //создадим новую переменную str_year_of_birth
	string str_year_of_birth {"nineteen ninety five"};
    
	std::cout << str_year_of_birth << std::endl;

	return 0;
}


           ИЗМЕНЯЕМЫЕ И НЕИЗМЕНЯЕМЫЕ ТИПЫ ДАННЫХ
_________________________________________________________           
Типы данных в Python можно разделить на изменяемые и неизменяемые.

Когда мы присваиваем новое значение неизменяемому объекту, 
Python не перезаписывает его, а создаёт новый объект с тем же 
именем. Чтобы в этом убедиться, достаточно проверить 
id — уникальный номер, который присваивается каждому 
объекту в Python:

#числовые типы в Python — неизменяемые
int_obj = 10

print("id of int_obj: ", id(int_obj)) #140717895746096

int_obj += 5
print("id of int_obj: ", id(int_obj)) #140717895746256
Когда мы прибавляем 5 к переменной int_obj, на её месте 
создаётся новый объект с тем же именем. Заметьте: при 
первом выводе id равен 140717895746096, а после выполнения
операции сложения — 140717895746256.

А вот идентификатор списка list_obj не меняется, потому что
 списки в Python — это изменяемые объекты:

#а объекты типа list — изменяемые
list_obj = [10, 20, 30]
print("id of list_obj: ", id(list_obj)) #2302150079496

list_obj += [40]

print("id of list_obj: ", id(list_obj)) #2302150079496

К неизменяемым объектам относятся числа, строки и кортежи,
 а к изменяемым — списки, словари и множества. Это свойство 
 нужно учитывать при передаче объектов в функцию. Например,
  если вы не хотите, чтобы функция изменила исходный список,
   передайте в неё копию этого списка.


                   ТИПЫ ДАННЫХ
___________________________________________________   

Теперь рассмотрим встроенные типы данных языка Python.
В недрах интерпретатора Python зашито много типов данных - 
это ВСТРОЕННЫЕ ТИПЫ Их можно разделить на три группы:

Простые — числа и строки.
Коллекции — списки, кортежи и словари.
Остальные — файлы, итераторы, сокеты, NaN.

****
Отдавайте предпочтение встроенным типам. Они упрощают 
разработку и более эффективны, чем пользовательские классы, 
потому что представляют собой оптимизированные структуры 
данных на языке C.
****

             ЧИСЛА
___________________________________
int 
float
long- размер в пайтоне не ограничен
complex

Арифметика: используй встроенную библ. (import math)
import math
a = 20.5
b = 10

#факториал числа b
math_factor = math.factorial(b)
print(math_factor) #результат: 3628800

#посчитать остаток от деления a на b
math_fmod = math.fmod(a, b)
print(math_fmod) #результат:0.5

#отсечь дробную часть у числа a
math_trunc = math.trunc(a)
print(math_trunc) #результат: 20


               СТРОКИ 
 ____________________________________              
Строки (string) — это последовательности символов, поэтому 
к ним применимы многие методы других последовательностей: 
списков и кортежей. Например, обращение к элементу по индексу,
 вычисление количества символов, конкатенация и получение среза.

first_str = 'skill'
second_str = 'box'

#конкатенация строк
some_string = first_str + second_str
print(some_string) #skillbox

#длина строки
length = len(some_string)
print(length) #8

#первый символ строки
first_symbol = some_string[0]
print(first_symbol) #s

#срез строки с первого по пятый символ
skill_slice = some_string[0:5]
print(skill_slice) #skill
Строки поддерживают работу с отрицательными индексами.
 Их удобно использовать, когда нужно обратиться к элементу с конца:

#последний символ строки
last_symbol = some_string[-1]
print(last_symbol) #x

#последние три символа строки 'skillbox'
box_slice = some_string[-3:]
print(box_slice) #box
Кроме того, у типа string есть ряд методов, уникальных для него:

#поиск подстроки
#если подстрока найдена, метод вернёт позицию её первого элемента, если нет — вернёт -1
ill_substr = some_string.find('ill')
print(ill_substr)

#поиск подстроки с заменой, заменим skill на school
school_box = some_string.replace('skill', 'school')
print(school_box) #schoolbox

#разбить строку по разделителю
student_name = 'Ivan_Ivanovich_Petrov'
list_of_substr = student_name.split('_')
print(list_of_substr) #['Ivan', 'Ivanovich', 'Petrov']

Преобразовать список в строку:
list1 = ['Hello', 'world', '!']
str1 = ' '.join(list1)

                       СПИСОК
________________________________________________________                       
Список (list) — это упорядоченная коллекция объектов. 

Чтобы создать список в Python, используйте квадратные скобки []

Список имеет переменную длину, а кортеж имеет фиксированную длину. Следовательно, список может быть изменен, а кортеж — нет.


Списки могут иметь сколько угодно уровней вложенности и 
хранить неограниченное количество объектов. 
Кроме того, в одном списке могут одновременно храниться 
объекты разных типов.

Над списками можно производить те же операции, что и над строками:

some_list = ['s', 'k', 'i', 'l', 'l', 'b', 'o', 'x']

#первый символ списка
list_first_symbol = some_list[0]
print(list_first_symbol) #s

#срез списка с первого по пятый элемент
list_slice = some_list[0:5]
print(list_slice) #['s', 'k', 'i', 'l', 'l']

#последний элемент списка
list_last_symbol = some_list[-1]
print(list_last_symbol) #x

Но у списков есть и специфические методы, которые присущи
 только им. Например, можно добавить новый элемент в конце 
 списка, удалить i-й элемент или отсортировать список:

#добавить новый элемент в конец списка
some_list.append('!')
print(some_list) #['s', 'k', 'i', 'l', 'l', 'b', 'o', 'x', '!']

#удалить элемент с индексом 3
some_list.pop(3)
print(some_list) #'s', 'k', 'i', 'l', 'b', 'o', 'x', '!']

# удалить элемент с фиксированным значением
some_list.remove(element)

#отсортировать элементы списка в порядке возрастания
some_list.sort()
print(some_list) #['!', 'b', 'i', 'k', 'l', 'o', 's', 'x']

                        Функции и методы списков

Создать создали, теперь нужно со списком что-то делать. Для списков доступны основные встроенные функции, а также методы списков.

Таблица "методы списков"
Метод	           Что делает
list.append(x)	Добавляет элемент в конец списка
list.extend(L)	Расширяет список list, добавляя в конец все элементы списка L
list.insert(i, x)	Вставляет на i-ый элемент значение x
list.remove(x)	Удаляет первый элемент в списке, имеющий значение x.          
                ValueError, если такого элемента не существует
list.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс 
                не указан, удаляется последний элемент
list.index(x, [start [, end]])	Возвращает положение первого элемента 
                 со значением x (при этом поиск ведется от start до end)
list.count(x)	Возвращает количество элементов со значением x
list.sort([key=функция])	Сортирует список на основе функции
list.reverse()	Разворачивает список
list.copy()	Поверхностная копия списка
list.clear()	Очищает список

Нужно отметить, что методы списков, в отличие от строковых методов,
 изменяют сам список, а потому 
 
 результат выполнения не нужно записывать в эту переменную.
  НУЖНО ПРОСТО ВЫВОДИТЬ ТОТ ЖЕ СПИСОК (но его содержание уже будет другим)

>>>
>>> l = [1, 2, 3, 5, 7]
>>> l.sort()
>>> l
[1, 2, 3, 5, 7]
>>> l = l.sort()
>>> print(l)
None
И, напоследок, примеры работы со списками:

>>>
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]

                КОРТЕЖИ
_______________________________________________                
Кортежи (tuple) — это те же списки, только неизменяемые. 
Над ними можно производить те же операции, что и над списками,
 — кроме тех, которые изменяют кортеж:

some_tuple = ('p', 'y', 't', 'h', 'o', 'n')

Чтобы создать кортеж в Python, используйте круглые скобки ()

Список имеет переменную длину, а кортеж имеет фиксированную длину. Следовательно, список может быть изменен, а кортеж — нет.

#последний элемент кортежа
last_element = some_tuple[-1]
print(last_element)

#срез кортежа с первого по третий элемент
tuple_slice = some_tuple[0:3]
print(tuple_slice)

#меняем значение первого элемента
some_tuple[0] = 'c'

При попытке заменить элемент 'p' на 'c' Python выдаст сообщение
 об ошибке:

TypeError: 'tuple' object does not support item assignment

Вы спросите: зачем нужны кортежи, когда есть списки с более 
широким набором методов и операций? Как мы уже сказали выше,
 иногда программистам важно быть уверенными, что функция не 
 изменит значение объекта. Как раз для таких случаев и годятся 
 кортежи.

Преобразование списка в кортеж в Python
Чтобы перевести список Python в кортеж, используйте функцию tuple(). tuple() — это встроенная функция, которая передает список в качестве аргумента и возвращает кортеж. Элементы списка не изменятся при преобразовании в кортеж. Это самый простой способ преобразования.

Сначала создайте список и преобразуйте его в кортеж с помощью метода tuple().

mando = ["Mandalorian", "Grogu", "Ahsoka Tano", "Bo Katan", "Boba Fett"]
print(mando)
print(type(mando))

mando_tuple = tuple(mando)
print(mando_tuple)
print(type(mando_tuple))

Вывод:

['Mandalorian', 'Grogu', 'Ahsoka Tano', 'Bo Katan', 'Boba Fett']
<class 'list'>('Mandalorian', 'Grogu', 'Ahsoka Tano', 'Bo Katan', 'Boba Fett')
<class 'tuple'>

Из версии Python 3.5 и выше вы можете сделать этот простой подход, который создаст преобразование из списка в кортеж(*list, ).(*list, ) распаковывает список внутри литерала кортежа, созданного из-за наличия одиночной запятой(, ).

mando = ["Mandalorian", "Grogu", "Ahsoka Tano", "Bo Katan", "Boba Fett"]
print(mando)
print(type(mando))

mando_tuple =(*mando, )
print(mando_tuple)
print(type(mando_tuple))

Вывод:

['Mandalorian', 'Grogu', 'Ahsoka Tano', 'Bo Katan', 'Boba Fett']
<class 'list'>('Mandalorian', 'Grogu', 'Ahsoka Tano', 'Bo Katan', 'Boba Fett')
<class 'tuple'>

Вы можете видеть, что(*mando, ) возвращает кортеж, содержащий все элементы списка. Никогда не используйте имена переменных, такие как tuple, list, dictionary или set, чтобы улучшить читаемость кода. Иногда это будет создавать путаницу. Не используйте зарезервированные ключевые слова при присвоении имени переменной.

В Python 2.x, если вы по ошибке переопределили кортеж как кортеж, а не как кортеж типа, вы получите следующую ошибку:

TypeError: объект ‘tuple’ не вызывается.



                   СЛОВАРИ
_____________________________________________
Словарь (dict) — это неупорядоченная коллекция пар 
«ключ — значение». В качестве ключей могут выступать 
любые неизменяемые объекты (числа, строки и даже кортежи).

Получать доступ к элементам, удалять и создавать новые
 довольно просто:

#словарь с данными об ученике Skillbox
some_dict = {'first_name':'Алексей', 
             'age':35, 'is_paid':True, 
             'courses':['python', 'javascript', 'html/css'], }
print(some_dict)

#элемент с ключом 'last_name'
print(some_dict['first_name']) # 'Алексей'

#создать элемент, присвоив значение несуществующему ключу
some_dict['second_name'] = 'Петров'
print(some_dict)
#{'first_name': 'Алексей', 'age': 35, 'is_paid': True, 'courses': ['python', 'javascript', 'html/css'], 'second_name': 'Петров'}

del some_dict['is_paid']
print(some_dict)
#{'first_name': 'Алексей', 'age': 35, 'courses': ['python', 'javascript', 'html/css'], 'second_name': 'Петров'}
В качестве значений словарь может хранить объекты совершенно
 разных типов — даже другие словари. Глубина вложенности 
 не ограничена.

Так как словари являются отображениями, а не последовательностями, 
то элементы в них не упорядочены. Это значит, что при выводе 
элементов в цикле for их порядок не всегда будет совпадать
 с порядком, заданным при инициализации словаря.

Файлы
Объекты-файлы позволяют работать с файловой системой компьютера. 
Чтобы создать такой объект, нужно передать функции open имя
 файла и режим доступа (чтение или запись).

Допустим, вы собрались написать книгу о Python. Тогда нужно 
создать файловый объект в режиме записи — w write, а затем 
записывать в него строки текста с помощью метода write ():

#начнём с первой главы
#создадим файл с книгой в текущей папке
my_book = open("my_book.txt", 'w')
my_book.write('Chapter 1: Hello, Python!\n')
my_book.write('To be continued...\n')
#закроем поток записи
my_book.close()
А теперь проверим, всё ли сохранилось как надо. Для этого
создадим новый объект-файл с помощью той же функции open, 
но в режиме чтения — r read:

#откроем нашу книгу и проверим содержимое
book = open("my_book.txt", 'r')
text = book.read()
print(text)
Как вы можете убедиться, все строки, которые мы записали
 в файл, на месте.
____________________________________________________

Тема:            УСЛОВИЕ
_____________________________________________________

Конструкция IF

x = int(input('Введите число: '))
# ЕСЛИ условие_верно: выполнить_действие
if x > 0:
    print('Условие сработало! х > 0')
    y = int(input('У вас все хорошо?'))
    print('y')
   # Конструкция ELSE
else:
    print('Условие неверно! х<0')
# После if следующая строка обяза-но с отступом,
# иначе условие не сработает

 ELIF - промежуточное условие



 IF, ELIF, ELSE всешда пишутся сновой строчки, 
  БЕЗ пробелов перед ними, 
  а слдествия из них пишутся С ПРОБЕЛОМ, 
  т.к. иначе они будут рассматриваться не как следствия, 
  а как часть команды
  

  ___________________________________________________
  
  ОПЕРАТОРЫ СРАВНЕНИЯ
  ___________________________________________________
  
  > больше
  < меньше
  >= больше или равно
  <= меньше или равно
  == проверка на равенство (равно)
  != не равно
  = присвоение значения (не то же самое, что ==)



  _______________________________________________________

     ЛОГИЧЕСКИЕ ОПЕРАТОРЫ
  _______________________________________________________   

and - конъюнкция (логическое И: ВСЕ условия д.б. верны). Логическое умножение

or - дизъюнкиця (логическое ИЛИ, хотя бы ОДНО условие д.б. верно).    Логическая    сумма

not - НЕ: отрицание. Если утверждение верно, то противоположное есу - ложно. И наоборот

См. Таблица истинности сложных суждений

nnnnn
